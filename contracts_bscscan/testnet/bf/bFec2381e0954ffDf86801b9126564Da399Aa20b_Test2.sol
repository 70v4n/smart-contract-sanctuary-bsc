/**
 *Submitted for verification at BscScan.com on 2022-01-23
*/

//                 ....    ...      ....                     ..... ..... ....                          
//                   ..    .    ........       .,:::::::;. ..  ..    .    ..      .                    
//                .. ...   ..    .. ...... .   .cxxxxxxko' ..    .....  .  .........                   
//                .   ...   .   ......  .      .cxxxxxxxo' ....     .      .....  ..                   
//                .    .....    .  ....    ... .cxxxxxxxo' .  .  .....    .  ...   .                   
//                ..    .  ..  ..,:co;. .  . . .cxxxxxxxo' ... . .:dlc;'..  .. ..  .                   
//                ......   ..':ldxxxx:.   .... .cxxxxxxxo' .   . .cxxxxxoc;.. ..  ..                   
//     .  ...     . ...  .':oxxxxxxxx:. .. ... .cxxxxxxxo' ..  . .cxxxxxxxxdl;...  ... .....           
//   ....   ..   ..  ...;lxxxxxxxxxxx:.  ..  . .cxxxxxxxo' .  .. .cxxxxxxxxxxxdc,.  .......... ..  .   
//    ......     .. .':dxxxxxxxxxxxxx:. .. .   .cxxxxxxxo'   ..  .cxxxxxxxxxxxxxxo;..   ........       
//  ..  ...  ... ...cdxxxxxxxxxxxxxxd;. .... . .cxxxxxxxo' ... . .,ldxxxxxxxxxxxxxxo;..    .  ...      
// ...   ...... ..:dxxxxxxxxxxxxxoc,.. .. .  . .',,,,,,,'. .. ... ..';cdxxxxxxxxxxxxxl,.   ..     ..   
// ..     ..   .'lxxxxxxxxxxxxdc,..  ..  .. .             .. ..  ...  ..;lxxxxxxxxxxxxdc.....  ..  .   
// .  ..   .. .;dxxxxxxxxxxxd:'.  ..........     ....  .... .. ..  ..  . .,cdxxxxxxxxxxxo,. ..   ...   
//  .....  . .cxxxxxxxxxxxdc.. ..    .... .....  ..........   .  .. .  ... .,lxxxxxxxxxxxd;.  ..   .   
// ..   ..  .cxxxxxxxxxxxl'. .  .  .. .. . . ..';:loodddolc;'... ..  ..  .....;oxxxxxxxxxxd;.    ..    
//  .. . . .cxxxxxxxxxxd:.       ...  ..  ..,:odxxxxxxxxxxxxdc'.   .  ..  ... .'lxxxxxxxxxxd;. .....   
//     .  .:xxxxxxxxxxd;. .....    ...  ..:oxxxxxxxxxxxdollldxd:. .. ....... .  .cxxxxxxxxxxd,. ...    
//    .  .,dxxxxxxxxxd;. .  ..  . ..  .'cdxxxxxxxxdo:;,'....,oxxc.   ....  .. .. .cxxxxxxxxxxl. .  .   
//     . .lxxxxxxxxxx:. ...  . .  . ..cdxxxxxxxxo:'..  .... .:xxd;. .....   .  .. .lxxxxxxxxxx:.  ..   
// .  . .;dxxxxxxxxxl. ....  .... ..:dxxxxxxxooxo. ........ .:xxxl. .  ..   .. ..  ,dxxxxxxxxxo' .     
//  . . .lxxxxxxxxxd,... .  .  . .,oxxxxxxxl,.cxd,. ...  .. .cxxxo. .         . .. .:xxxxxxxxxx:. ..   
// .  . 'oxxxxxxxxxl. . .. .    .,dxxxxxxl,. .:xd;. ...  . .,dxxxl. ...    .  ..  . ,dxxxxxxxxxl. .    
//   . .,dxxxxxxxxx:. ......... .:xxxxxo;.   .:xx;...   . .'oxxxd;. . .     .. .. . .lxxxxxxxxko. ..   
//   . .;xxxxxxxxxx;. . .. ..   .;xxxd:..  . .:xx;. .... .,oxxxx:. . ..        .... .cxxxxxxxxxo' ..   
//  .. .:xxxxxxxxxx;... . ..  .. ,dxo,. . .. .;xx:. .  .'cdxxxd:.  .              . .cxxxxxxxxxd' ..   
//  .. .;xxxxxxxxxx:. .  ..  ..  .cc..        ,dx:. ..,cdxxxxd;...                . .cxxxxxxxxxo' .    
//  ..  ,dxxxxxxxxxc. .. .. .. . .....     .  ,dxl;:odxxxxxxl'.  ..         ..    . .oxxxxxxxxxo. ..   
//   .. 'oxxxxxxxxxo. .  ..... .. .. ..   ...,lxxxxxxxxxxxl,....  .         .  ..  .,dxxxxxxxxxc.      
// .  . .cxxxxxxxxxx;. .  .... .. ...  .  .:oxxxxxxxxxxdl,.........          . ... .cxxxxxxxxxd;.  .   
//    . .,dxxxxxxxxxo'.  .     .    .  .. 'dxxxxxxxdlc:'. ..    .  ....    ..  .  .;dxxxxxxxxxl.   .   
//   .   .cxxxxxxxxxxl. .. .   ...  .  .. .:oddxxdc'... . ..   ..  .....  . ..   .'oxxxxxxxxxd;. .     
//  ...   'oxxxxxxxxxxc. ......   .    ... ...;dxd;. ......   .............  .  .'oxxxxxxxxxxc. .  .   
// ..  .. .,dxxxxxxxxxxc.. .   ..       ..  . .oxxc. .....    ...    ........  .'oxxxxxxxxxxo' ....    
//   ..  . .;dxxxxxxxxxxl'. ........    ..  . .cxxo' ..    .    .   .. .... . .;dxxxxxxxxxxo'.   ..    
// ...  ..  .;dxxxxxxxxxxd:.. ..  ...  ..  .. .,dxd;...  .  ..     ......   .'cdxxxxxxxxxxo'. ......   
// ...  .... .;dxxxxxxxxxxxo;.  .  ...      .. .lxxc.  ...   ....  .. ..  ..:dxxxxxxxxxxxl'.  ......   
// ..   .. .. .'lxxxxxxxxxxxxo;.. .....  ...   .'co;.   ..     .   ..   .':oxxxxxxxxxxxdc...........   
// ..  ... .  ...:dxxxxxxxxxxxxo:,..  . ..  .. .....      .   ...... ..;ldxxxxxxxxxxxxo,.   ..   ...   
//     .... .. . .'lxxxxxxxxxxxxxxoc,...   ....  ..  ....  ...   ..';cdxxxxxxxxxxxxxd:.. .  ...   .    
//                 .,lxxxxxxxxxxxxxxxdlc;,.....           ....',:codxxxxxxxxxxxxxxdc'.   .  ...        
//                .  .,ldxxxxxxxxxl:coddxxdolcc:;;;;;;;;::ccoddxxxddlclxxxxxxxxxd:'.  .  .  ..         
//                .  . .':oxxxxxxo:cc;clclododxxxxxxxxxxxxxdxdlooccc;;:ldxxxxdl;.. ..  ..  ...         
//                 ..  ....,:oxxxddxdccl::;;;:l::clc::ll:ll;cl,,c:cccoloxxdl:'.  .  .. .......         
//                     .... ..';loxxxxooddcc:;lc;lc;;,:c;;;:ccclloodxxdoc;'...   ............          
//                ...  ..    .  ..';clodxxxxxdxdodooooodddddxxxxxdoc:,'..  . .....                     
//                ...     .. ...    ....,;::cllooddddddooollc:;,'...    .. .......               ...   
//                ..  .   ......     ..     .................    .          ... ...             ...    
//                                         .................                                           
                                                                                                    


pragma solidity 0.5.17;

// Interface of a token BEP20 - ERC20 - TRC20 - .... All functions of the standard interface are declared, even if not used
interface TOKEN20 {
    function totalSupply() external view returns (uint);
    function balanceOf(address tokenOwner) external view returns (uint balance);
    function allowance(address tokenOwner, address spender) external view returns (uint remaining);
    function transfer(address to, uint tokens) external returns (bool success);
    function approve(address spender, uint tokens) external returns (bool success);
    function transferFrom(address from, address to, uint tokens) external returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}

// Define the abstract contract for an ownable contract with transfer ownership (requires accept) and modifier for owner only functions
contract Ownable
{
    address payable public ownerWallet;     // The wallet Owner
    address payable public newOwner;        // The wallet new Owner (before confirmation)

    event OwnershipTransferredEv(address indexed previousOwner, address indexed newOwner);

    constructor() public
    {
        //Set contract owner
        ownerWallet = msg.sender;
    }

    function transferOwnership(address payable _newOwner) public onlyOwner
    {
        // Set the new owner, but this needs confirmation from the new owner (accept ownership)
        newOwner = _newOwner;
    }

    function acceptOwnership() public
    {
        // Only new owner can accept the ownership transfer
        require(msg.sender == newOwner);
        emit OwnershipTransferredEv(ownerWallet, newOwner);
        ownerWallet = newOwner;
        newOwner = address(0);
    }

    // Modifier to be used with functions that can be called only by owner
    modifier onlyOwner()
    {
        require(msg.sender == ownerWallet, "Permission Denied");
        _;
    }

}


// MAIN CONTRACT
contract Test2 is Ownable {

    // Constants
    address public constant address_zero = address(0);      // The address(0)
    address public constant headPlaceholder = address(1);   // Address associated to the ID1 as placeholder. Real coins go to headWallet     
    uint8 public constant maxDownLimit = 5;     // Max number of direct spots under a user (first level downline)
    uint private constant coin_unit = 1e18;      // A coin unit (18 decimals)
    uint private constant max_iterations = maxDownLimit + maxDownLimit**2 + maxDownLimit**3;    // Max iterations for the placement algorithm - 3 full levels
    uint private constant max_expand_index = maxDownLimit + maxDownLimit**2 - 1;    // Max index (included) for the spotFinder function, for the expansion of the downline

    // Global Variables
    address public token_addr;              // Address of the used token (eg. BUSD token)  
    uint8[] public commission_per_level;    // Commissions for each level. 6 elements, the first is for the sponsor, other 5 for the upline (down to up)
    uint public lastIDCount = 0;            // Last ID of the matrix (1 to last). This is also the number of users
    uint private PIDcount = 0;              // Purchase unique ID identifier/counter
    address public projectWallet;           // Wallet where to send the project fee (50%). It can be changed
    address public headWallet;              // Wallet linked to the head, the ID1 destination for commissions, aka Team One
    address private approveWallet;          // Wallet used to only ban/unban (eg. for KYC approvals)
    bool public bannedLogic = true;         // Logic associated to banned variable (true means that banned=true is banned)
    bool public businessEnabled = true;     // Globally enable the smart contract

    // Data structures

    // A USER (PLAYER)
    struct userStructure {
        uint id;                                // The ID. If user exists the ID is >0
        uint referrerID;                        // native ID who referred the User (sponsor)
        uint virtualID;                         // REAL upline for the User (due to forced matrix system, after placement)
        uint[] invitedIDs;                      // dynamic array with invited users (IDs). Length is directly_invited. Length is number of invited
        uint[] downlineIDs;                     // array of downline IDs, can be max 5 (forced matrix). Length is the number of directs
        uint32 round_robin_next_index;          // Next index (of downlineIDs) to add to the round_robin when one gets deleted, starts from maxDownLimit (5) 
        mapping(uint => uint) round_robin;      // round robin memory for the spillover distribution
        bool banned;                            // Used to ban (disable) the user
        uint totalEarned;                       // Total earned for the user (all Packages)
        mapping(uint16 => userPackageData) packagesData;      // Data related to a particular Package
        uint[] bought_packages_array;           // Array of ALL bought packages - PID references (timeline)
    }

    // Information about a particular package from the perspective of a player
    struct userPackageData {
        uint[] bought_array;        // Array with PIDs of bought packages. Last element is the most recent. Length is the Number of time this package has been bought is
        uint totalEarnedPack;       // Total BUSD earned from downline related to the selling activity on this package
    }

    // Purchase structure (store data of a purchase)
    struct PurchaseInfo {
        uint userID;                // Player who bought the package
        uint16 packageID;           // ID of the package (first package is the mandatory package)
        uint timestamp;             // Purchase Timestamp in s
        uint duration;              // saved duration associated to this package (at the buy time)
    }

    // A PACKAGE (service/product, like a course category or a subscription)
    struct packageStructure {
        uint price;                 // Price in BUSD cents (1e18). Package exists if > 0 (price always > 0.001)
        uint duration;              // Duration in seconds. 0 means never expires (one-shot)
        bool enabled;               // Status of the package. If disabled it cannot be bought/activated
        bool rebuy_enabled;         // Enable rebuy of the package (subscription mode)
        bool rebuy_before_exp;      // Enable rebuy before expiration (concurrent subscription mode). Used only when rebuy_enabled and saved duration > 0
        uint16[] prerequisites;     // Required packages (except 1) to unlock (allow to buy) this package
        bool prereq_not_exp;        // Define if expiration (bought TS + duration) must be checked before buy, in case of a prerequisite with saved duration > 0
    }


    // Database (global mappings and arrays)
    mapping(uint16 => packageStructure) public packagesIndex;       // Storage for the packages profiles
    uint16[] public addedPackages;                                  // Storage for the IDs of the added packages (packageID can be arbitrary code)
    mapping(uint => address) public userIDaddress;                  // Storage for mapping the user IDs to related addresses (structure)
    mapping(address => userStructure) public userInfos;             // The matrix
    mapping(uint => PurchaseInfo) public purchasesList;             // Storage for the purchases (access with PID)
    
    // Events ACL feature (manage subscription to classes/lessons/events with unique client side tickets).
    // packageID -> Event UID (wallet address) -> UserID -> Event registration Timestamp (or 0)
    mapping(uint16 => mapping(address => mapping(uint => uint))) private eventsACL;
    // Hashed Unique Ticket -> userID (>0 means used)
    mapping(bytes32 => uint) private ticketUserID;


    // Events 
    event UserRegistrationEv(uint32 indexed timestamp_hour, uint32 indexed timestamp_days, uint userID, address userAddr);
    event PurchasePackageEv(uint32 indexed timestamp_hour, uint32 indexed timestamp_days, uint userID, uint16 packageID, uint PID);
    event PaidUplineEv(uint indexed user, uint16 indexed packageID, uint tot_amount_upline, uint tot_amount_remaining, uint tot_amount_project);
    event ChangedBanStatusEv(uint indexed user, bool indexed new_status, bool logic);        
    event ChangedApproveStatusEv(uint indexed user, bool indexed new_status, bool logic);  
    event ChangedFeatureParameterEv(string indexed tag);    // Indexed strings are saved as keccak256(string)
    event AddEditPackageEv(uint16 indexed packageID, uint price, bool is_new_add);
    event RegisterToEventEv(uint16 indexed packageID, address indexed eventUID, uint userID);


    // Constructor called when deploying
    constructor(address _token_addr, address _projectWallet, address _headWallet, address _approveWallet) public {
        ownerWallet = msg.sender;
        changeTokenUsed(_token_addr);
        projectWallet = _projectWallet;
        headWallet = _headWallet;
        approveWallet = _approveWallet;
        // Create the head. Parameters not set are the default ones (eg. 0, false, empty array...)
        lastIDCount = 1;
        userIDaddress[1] = headPlaceholder;
        userInfos[headPlaceholder].id = 1;
        userInfos[headPlaceholder].banned = !bannedLogic;
        userInfos[headPlaceholder].round_robin_next_index = maxDownLimit;
        emit UserRegistrationEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), 1, headPlaceholder);
        // --------
        // Set the default commission percentages (divider is 100)
        // index 0 : commission for the sponsor (who invites)
        // index 1 to index MaxDownLimit+1 (6) : commissions for the uplines (parents) going up from the payer
        commission_per_level = [10, 10, 9, 8, 6, 7];
        // --------
        // Create the BASE (mandatory) package and the other 3 expected first packages of the project. Prices are in USD (the token_addr is expected to be BUSD)
        uint16[] memory empty_array;
        addEditPackage(1, 179, false, false, 0, true, false, false, empty_array, false);
        addEditPackage(2, 600, false, false, 0, true, false, false, empty_array, false);
        addEditPackage(3, 1180, false, false, 0, true, false, false, empty_array, false);
        addEditPackage(4, 1750, false, false, 0, true, false, false, empty_array, false);
    }


    // Register a new user (by buying packageID 1) using the given sponsorID. Or Buy a generic Package (after registration) with the given PackageID (sponsor is ignored, hierarchy is defined by the registration).
    // Some packages can be rebought, some have an expiration, some are hybrid, depending on the added packages.
    // Commissions are paid to the sponsor and the upline levels, a part goes to the project wallet.
    function BuyPackage(uint sponsorID, uint16 packageID) public {
        require(businessEnabled, "Business non enabled");
        require(!isContract(msg.sender) && msg.sender == tx.origin, "Smart Contracts not Allowed");
        require(msg.sender != headWallet && msg.sender != projectWallet && msg.sender != headPlaceholder && msg.sender != approveWallet, "This wallet cannot buy");
        require(packagesIndex[packageID].enabled, "Package not exists or not enabled");
        // -------------
        // If the user is new, package 1 is required to buy. The sponsor is associated to the user and the player placed into the matrix
        if (userInfos[msg.sender].id == 0) {
            require(sponsorID <= lastIDCount && sponsorID > 0, "You must give a valid sponsor ID");
            require(packageID == 1, "New registration require package 1");
            // Place the user in the matrix, using the algorithm 
            placeNewUser(msg.sender, userIDaddress[sponsorID]);
            emit UserRegistrationEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), userInfos[msg.sender].id, msg.sender);
        }
        // -------------
        // Checks before buying the package...
        // User is not banned
    	require(bannedLogic ? !userInfos[msg.sender].banned : userInfos[msg.sender].banned, "User is banned/disabled");
        // The package must be enabled
        require(packagesIndex[packageID].enabled, "Package not enabled");
        // Check if rebuy is active and user already bought. discriminate between cases with and without expiration check
        uint n_bought = userInfos[msg.sender].packagesData[packageID].bought_array.length;
        if (n_bought > 0) {
            require(packagesIndex[packageID].rebuy_enabled, "Rebuy not enabled for this package");
            uint last_pid = userInfos[msg.sender].packagesData[packageID].bought_array[n_bought-1];
            if (purchasesList[last_pid].duration > 0 && block.timestamp < purchasesList[last_pid].timestamp + purchasesList[last_pid].duration) {
                // Last purchase of the same packageID not expired!
                require(packagesIndex[packageID].rebuy_before_exp, "Rebuy before expiration not allowed for this package");
            }
        }
        // Check prerequisites of the package
        for (uint8 i = 0; i < packagesIndex[packageID].prerequisites.length; i++) {
            // Package must me already bought (at least once, if the prerequisite is a package that allows rebuy)
            uint16 currentPrerequisite = packagesIndex[packageID].prerequisites[i];
            require(userInfos[msg.sender].packagesData[currentPrerequisite].bought_array.length > 0, "Prerequisites not fulfilled");
            uint n_bought_rereq = userInfos[msg.sender].packagesData[currentPrerequisite].bought_array.length;
            uint last_pid_prereq = userInfos[msg.sender].packagesData[currentPrerequisite].bought_array[n_bought_rereq-1];
            // If the check of expiration (not expired) is enabled and the prerequisite has an expiration, it must not be expired to buy the source packageID
            if (packagesIndex[packageID].prereq_not_exp && purchasesList[last_pid_prereq].duration > 0) {
                require(block.timestamp <= purchasesList[last_pid_prereq].timestamp + purchasesList[last_pid_prereq].duration, "Prerequisite expired");
            }
        }
        // ----------------
        // Buy the package and pay the commissions
        // Create the purchase
        PurchaseInfo memory purchase = PurchaseInfo({
            userID: userInfos[msg.sender].id,
            packageID: packageID,
            timestamp: block.timestamp,
            duration: packagesIndex[packageID].duration
        });
        PIDcount++;
        purchasesList[PIDcount] = purchase;
        // Update user data
        userInfos[msg.sender].bought_packages_array.push(PIDcount);
        userInfos[msg.sender].packagesData[packageID].bought_array.push(PIDcount);
        // Transfer the money (tokens) to the contract
        depositTokenContract(packagesIndex[packageID].price);
        emit PurchasePackageEv(uint32(block.timestamp/3600), uint32(block.timestamp/86400), userInfos[msg.sender].id, packageID, PIDcount);
        // Distribute the payment (commissions and project wallet)
        payCommissions(msg.sender, packageID);
    }


    // Pay the commissions to the network and the project business. Update the earning statistics for the players/packages.
    // SafeMath library not used, because the code is written to ensure that overflow/underflow is impossible (packet prices are always > 0.01 sum of commission percentages is checked to be 100 in the setter admin function. Project fee is always > 1)
    function payCommissions(address payer, uint16 packageID) private {
        uint amount = packagesIndex[packageID].price;
        uint unpaid = amount;
        uint remaining = 0;
        // First send the commission to the sponsor
        address sponsor = userIDaddress[userInfos[payer].referrerID];
        uint toPay = amount*commission_per_level[0]/100;
        payUser20(sponsor, toPay);
        userInfos[sponsor].totalEarned += toPay;
        userInfos[sponsor].packagesData[packageID].totalEarnedPack += toPay;
        unpaid -= toPay;
        // Pay the upline, climbing parent by parent, for max 5 levels
        address currentUplineAddr = userIDaddress[userInfos[payer].virtualID];
        for (uint8 i = 1; i <= maxDownLimit; i++) {
            toPay = amount*commission_per_level[i]/100;
            if (currentUplineAddr == address(0)) {
                // The level is above the head, so it's a remaining
                remaining += toPay;
            } else {
                // Pay the level
                payUser20(currentUplineAddr, toPay);
                userInfos[currentUplineAddr].totalEarned += toPay;
                userInfos[currentUplineAddr].packagesData[packageID].totalEarnedPack += toPay;
                unpaid -= toPay;
            }
            // Go up to parent
            currentUplineAddr = userIDaddress[userInfos[currentUplineAddr].virtualID];
        }
        // Pay the remaining to the Head (ID 1)
        payUser20(headPlaceholder, remaining);
        userInfos[headPlaceholder].totalEarned += remaining;
        userInfos[headPlaceholder].packagesData[packageID].totalEarnedPack += remaining;
        unpaid -= remaining;
        // Pay the project fee (the unpaid) to the projectWallet
        payUser20(projectWallet, unpaid);
        userInfos[projectWallet].totalEarned += unpaid;
        emit PaidUplineEv(userInfos[payer].id, packageID, amount-unpaid-remaining, remaining, unpaid);
    }


    // Place the new user during the registration. This uses a hybrid placement system: for the first 5 invited users the placement occurs in the sponsor sub-structure (sub-matrix). 
    // After the 5 (maxDownLimit) invited users, a round-robin system is used, targeting the sub-structures of each of the first 5 invited people as starting point for the placement. 
    // For every new user, the next invited user (of the 5) is used as target, in a circular way, restarting from the the first invited user after the 5th.
    // The search for a free spot (placement) works only for the first 3 levels in the targeted sub-structure, if there are no free spots, the user is added under the last one that joined the smart contract (last ID). 
    // If a sub-structure associated to an invited user is full, the user is deleted from the round-robin circular list (5 elements) and replaced with a new invited user that is not yet in the list. For example the 6th invited user.
    function placeNewUser(address addr, address sponsorAddr) private {
        // Create the user
        lastIDCount++;
        userIDaddress[lastIDCount] = addr;
        userInfos[addr].id = lastIDCount;
        userInfos[addr].banned = !bannedLogic;
        userInfos[addr].referrerID = userInfos[sponsorAddr].id;
        userInfos[addr].round_robin_next_index = maxDownLimit;
        // Find the free spot... And place the user            
        // If we have less than maxDownLimit ALREADY INVITED users, we use the spotFinder search, from the sponsor, limited to 3 levels
        uint invitedCount = userInfos[sponsorAddr].invitedIDs.length;
        if (invitedCount < maxDownLimit) {
            (uint insertionID, address insertionAddr) = spotFinder(sponsorAddr);
            if (insertionID > 0) {
                // Place the user under the insertionID
                userInfos[insertionAddr].downlineIDs.push(lastIDCount);
                userInfos[addr].virtualID = insertionID;
            } else {
                // If spaces are full, use the last added user as upline
                userInfos[addr].virtualID = lastIDCount - 1;        // We already increased the count
                userInfos[userIDaddress[lastIDCount-1]].downlineIDs.push(lastIDCount);
            }
            // Update the sponsor data
            userInfos[sponsorAddr].invitedIDs.push(lastIDCount);
            userInfos[sponsorAddr].round_robin[invitedCount+1] = lastIDCount;
        // If we already have maxDownLimit invited users or more, use the round robin placement
        } else {
            // Scan the round robin memory and place search for a free spot in the affiliation structure of the invited players, round-robin order
            uint candidateID = userInfos[sponsorAddr].round_robin[invitedCount-maxDownLimit+1];
            (uint insertionID, address insertionAddr) = spotFinder(userIDaddress[candidateID]);
            if (insertionID > 0) {
                // Place the user under the insertionID
                userInfos[insertionAddr].downlineIDs.push(lastIDCount);
                userInfos[addr].virtualID = insertionID;
                // Update round robin memory to next: keep the same, there are still spots
                userInfos[sponsorAddr].round_robin[invitedCount+1] = candidateID;
            } else {
                // If spaces are full, use the last added user as upline
                userInfos[addr].virtualID = lastIDCount - 1;        // We already increased the count
                userInfos[userIDaddress[lastIDCount-1]].downlineIDs.push(lastIDCount);
                // Update round robin memory to next: move to the next invited user, discarding the full one (already has a decent structure), round_robin_next_index++
                userInfos[sponsorAddr].round_robin[invitedCount+1] = userInfos[sponsorAddr].invitedIDs[userInfos[sponsorAddr].round_robin_next_index];
                userInfos[sponsorAddr].round_robin_next_index++;
            }
            // Update the remaining sponsor data
            userInfos[sponsorAddr].invitedIDs.push(lastIDCount);
        }
    }

    // Search a free spot in the sub-structure (matrix) of the given user, considering the first 3 levels of the hierarchy. If there are no spots available, returns 0.
    function spotFinder(address referenceAddr) public view returns (uint insertionID, address insertionAddr) {
        // If the lv1 downline has free spots, place the user there and we have done
        if (userInfos[referenceAddr].downlineIDs.length < maxDownLimit) {
            return (userInfos[referenceAddr].id, referenceAddr);
        }
        // Search a spot in the first 3 level from the reference
        uint[] memory search_space = new uint[](max_iterations);
        for (uint8 i = 0; i < maxDownLimit; i++) {
            search_space[i] = userInfos[referenceAddr].downlineIDs[i];
        }
        for (uint16 i = 0; i < max_iterations; i++) {
            if (userInfos[userIDaddress[search_space[i]]].downlineIDs.length >= maxDownLimit) {
                // User is full
                // allocate the downline users for future search, if there is space in the search_space, then continue the search
                if (i <= max_expand_index) {
                    for (uint8 j = 0; j < maxDownLimit; j++) {
                        search_space[(i+1)*maxDownLimit+j] = userInfos[userIDaddress[search_space[i]]].downlineIDs[j];
                    }
                }
            } else {
                // There is a free spot under this user! This will be the insertionID!
                insertionID = search_space[i];
                insertionAddr = userIDaddress[search_space[i]];
                return (insertionID, insertionAddr);
            }
        }
        // Reached the end of the for cycle and not returned yet... So all spots are full!
        // In this case we return insertionID = 0 (not valid ID) and the caller function will manage the condition
        return (0, address(0));
    }



    // Internal function to manage the payment of a user, P2P, with the token
    function payUser20(address user, uint amount) internal {
            // Case of the user is the head
            if (user == headPlaceholder) {
                user = headWallet;
            }
            // Pay the commission directly (direct transfer). 
            // Token Transfer
            bool success = TOKEN20(token_addr).transfer(user, amount);      // Do the token transfer
            require(success, "Error executing the transaction");
    }


    // Utility function to send a token to the smart contract balance
    // The transaction must be approved externally (in JS frontend) with 
    // token_addr.approve(smart_contract, amount)
    function depositTokenContract(uint amount) private {
        require(amount > 0, "You are not sending anything!");
        bool success = TOKEN20(token_addr).transferFrom(msg.sender, address(this), amount);
        require(success, "Token transfer to contract failed. Check allowance!");
    }



    // Fallback function
    function () external payable {
        // Prevent users from using the fallback function to send money
        revert('Call/transfer not allowed in this way!');
    }


    // Check if an address is a Smart Contract
    function isContract(address addr) internal view returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }


    // -------------- Event ACL functions -----------------


    // Function to register to an Event, given the Event (packageID+eventUID - Event always associated to a packageID) and the hash of the generate personal unique Ticket (address like). Only a single registration is allowed (for a userID with a single Ticket)
    function registerToEvent(uint16 packageID, address eventUID, bytes32 ticket_hashed) public {
        uint userID = userInfos[msg.sender].id;
        require(userID > 1, "Not a user of the contract!");
        require(packagesIndex[packageID].enabled, "PackageID not enabled");
        require(ticketUserID[ticket_hashed] == 0, "Ticket already exists");
        require(eventsACL[packageID][eventUID][userID] == 0, "User already registered to the Event");
        // Register to the event
        eventsACL[packageID][eventUID][userID] = block.timestamp;
        ticketUserID[ticket_hashed] = userID;
        emit RegisterToEventEv(packageID, eventUID, userID);
    }


    // Check the registration list to an Event, given the PackageID+EventID and the ticked (address like). Returns the timestamp of the registration to the Event (if it's 0 it means the ticket not registered), the userID associated to the ticket and some useful data regarding the last Purchase of the given PackageID, for a quick check.
    function checkEventRegistration(uint16 packageID, address eventUID, address ticket) public view returns (uint reg_timestamp, uint userID, uint PID_last, uint timestamp_last, bool expired_last) {
        // Get the userID
        userID = ticketUserID[keccak256(abi.encodePacked(ticket))];
        // get the registration timestamp 
        reg_timestamp = eventsACL[packageID][eventUID][userID];
        if (userID > 0) {
            uint[] memory bought_array_PIDs = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array;
            if(bought_array_PIDs.length > 0) {
                PID_last = bought_array_PIDs[bought_array_PIDs.length-1];
                ( , , timestamp_last, , expired_last) = getPurchaseInfo(PID_last);
            }
        }
    }



    // ------------ Admin Functions -------------



    // Change the wallets used for the business costs, head code (associated to the head placeholder) and approve Wallet
    function changeBusinessWallets(address newProjectWallet, address newHeadWallet, address newApproveWallet) public onlyOwner {
        if (newProjectWallet != address(0)) {
            projectWallet = newProjectWallet;
            emit ChangedFeatureParameterEv("changeProjectWallet");
        }
        if (newHeadWallet != address(0)) {
            headWallet = newHeadWallet;
            emit ChangedFeatureParameterEv("changeHeadWallet");
        }
        if (newApproveWallet != address(0)) {
            approveWallet = newApproveWallet;
            emit ChangedFeatureParameterEv("changeApproveWallet");
        }
    }


    // Change the token used for the contract (default a stablecoin like BUSD)
    function changeTokenUsed(address token_used) public onlyOwner {
        require(token_used != address(0) && isContract(token_used), "Invalid token address");
        token_addr = token_used;
        emit ChangedFeatureParameterEv("changeTokenUsed");
    }


    // Change the commission percentages end project percentage. Every percentage must be > 0 and the sum must be 100 otherwise the transaction is rejected. Owner must define the invited (directly invited) percentage, the 5 level (upline) percentages. The remaining percentage must be the project percentage.
    function changePercentages(uint8 invited_percentage, uint8[] memory commission_percentages, uint8 project_percentage) public onlyOwner {
        require(invited_percentage > 0 && project_percentage > 0, "Check the values!");
        commission_per_level[0] = invited_percentage;
        uint16 sum_perc = invited_percentage + project_percentage;
        for (uint8 i = 0; i < maxDownLimit; i++) {
            require(commission_percentages[i] > 0, "Check the values!");
            commission_per_level[i+1] = commission_percentages[i];
            sum_perc += commission_percentages[i];
        }
        require(sum_perc == 100, "Check the values!");
        emit ChangedFeatureParameterEv("changePercentages");
    }


    // Enable or disable user interaction with the smart contract (Write)
    function enableBusiness(bool enable) public onlyOwner {
        businessEnabled = enable;
        emit ChangedFeatureParameterEv("enableBusiness");
    }


    // Change ban settings and/or ban/unban users
    function banUnban(bool changeBannedLogic, bool newBannedLogic, bool banUnbanUser, uint userID, bool newBanStatus) public onlyOwner {
        // Banned logic change
        if (changeBannedLogic) {
            bannedLogic = newBannedLogic;
            emit ChangedFeatureParameterEv("changeBannedLogic");
        }
        // Ban/Unban the user
        if (banUnbanUser) {
            require(userID > 1 && userID < lastIDCount, "Invalid UserID!");     // Can ban existing users except head
            userInfos[userIDaddress[userID]].banned = newBanStatus;
            emit ChangedBanStatusEv(userID, newBanStatus, bannedLogic);
        }
    }


    // Function used by approveWallet to ban/unban only (eg. KYC approval if needed in the future)
    function approveUnapprove(uint userID, bool newBanStatus) public {
        // Can be called only by approveWallet
        require(msg.sender == approveWallet, "Permission denied");
        require(userID > 1 && userID < lastIDCount, "Invalid UserID!");     // Can ban existing users except head
        userInfos[userIDaddress[userID]].banned = newBanStatus;
        emit ChangedApproveStatusEv(userID, newBanStatus, bannedLogic);
    }


    // Add a package or edit an existing package. Packages can only be added or edited
    function addEditPackage(uint16 packageID, uint price, bool price_is_cents, bool change_only_price, uint duration, bool enabled, bool rebuy_enabled, bool rebuy_before_exp, uint16[] memory prerequisites, bool prereq_not_exp) public onlyOwner {
        if (!price_is_cents) {
            price = price * coin_unit;
        }
        require(price > coin_unit/1000, "Price must be > 0.001 tokens");
        // Check if it's new or exists, add to the array if new
        if (packagesIndex[packageID].price == 0) {
            addedPackages.push(packageID);
            emit AddEditPackageEv(packageID, price, true);
        } else {
            emit AddEditPackageEv(packageID, price, false);
        }
        require(rebuy_before_exp ? rebuy_enabled : true, "Check configuration");
        // Add/edit parameters
        if (change_only_price) {
            require(packagesIndex[packageID].price > 0, "Package must already exist");
            packagesIndex[packageID].price = price;
        } else {
            packageStructure memory newPackage = packageStructure({
                price: price,
                duration: duration,
                enabled: enabled,
                rebuy_enabled: rebuy_enabled,
                rebuy_before_exp: rebuy_before_exp,
                prerequisites: prerequisites,
                prereq_not_exp: prereq_not_exp
            });
            packagesIndex[packageID] = newPackage;
        }
    }



    // ------------ View Functions -------------


    // Return information associated to a given packageID. If an optional (>0) userID is given, it returns also the total earned amount, the number of purchases and the last PID for the packageID for that userID (otherwise these variables will be 0)
    function getPackageInfo(uint16 packageID, uint userID) public view returns (uint price, uint duration, bool enabled, bool rebuy_enabled, bool rebuy_before_exp, uint16[] memory prerequisites, bool prereq_not_exp, uint totalEarnedPack, uint purchasesCount, uint last_pid) {
        require(packagesIndex[packageID].price > 0, "Package does not exists");
        price = packagesIndex[packageID].price;
        duration = packagesIndex[packageID].duration;
        enabled = packagesIndex[packageID].enabled;
        rebuy_enabled = packagesIndex[packageID].rebuy_enabled;
        rebuy_before_exp = packagesIndex[packageID].rebuy_before_exp;
        prereq_not_exp = packagesIndex[packageID].prereq_not_exp;
        prerequisites = packagesIndex[packageID].prerequisites;
        if (userID > 0) {
            require(userID <= lastIDCount, "Invalid userID");
            totalEarnedPack = userInfos[userIDaddress[userID]].packagesData[packageID].totalEarnedPack;
            purchasesCount = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array.length;
            if (purchasesCount > 0) {
                last_pid = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array[purchasesCount-1];
            }
        }
    }


    // Scan the added packages array in chunks and return information related to the packages
    function getAddedPackagesMainInfo(uint start_index, uint stop_index) public view returns (uint16[] memory packageID, uint[] memory price, uint[] memory duration, bool[] memory enabled, bool[] memory rebuy_enabled, bool[] memory rebuy_before_exp, bool[] memory has_prerequisites) {
        require(stop_index >= start_index, "Invalid index parameter");
        if (stop_index >= addedPackages.length) {
            stop_index = addedPackages.length - 1;
        }
        packageID = new uint16[](stop_index-start_index+1);
        price = new uint[](stop_index-start_index+1);
        duration = new uint[](stop_index-start_index+1);
        enabled = new bool[](stop_index-start_index+1);
        rebuy_enabled = new bool[](stop_index-start_index+1);
        rebuy_before_exp = new bool[](stop_index-start_index+1);
        has_prerequisites = new bool[](stop_index-start_index+1);
        for (uint i = start_index; i <= stop_index; i++) {
            uint16[] memory prerequisites;
            packageID[i] = addedPackages[i];
            (price[i], duration[i], enabled[i], rebuy_enabled[i], rebuy_before_exp[i], prerequisites, , , , ) = getPackageInfo(addedPackages[i], 0);
            has_prerequisites[i] = (prerequisites.length > 0);
        }
    }


    // Scan the added packages array in chunks and return information related to the packages but related to a particular userID: userID-related info are total earned, number of purchases, last purchase PID, last purchase timestamp and expiration
    function getAddedPackagesUserInfo(uint userID, uint start_index, uint stop_index) public view returns (uint16[] memory packageID, uint[] memory totalEarnedPack, uint[] memory purchasesCount, uint[] memory last_PID, uint[] memory last_timestamp, bool[] memory last_expired) {
        require(stop_index >= start_index, "Invalid index parameter");
        if (stop_index >= addedPackages.length) {
            stop_index = addedPackages.length - 1;
        }
        packageID = new uint16[](stop_index-start_index+1);
        totalEarnedPack = new uint[](stop_index-start_index+1);
        purchasesCount = new uint[](stop_index-start_index+1);
        last_PID = new uint[](stop_index-start_index+1);
        last_timestamp = new uint[](stop_index-start_index+1);
        last_expired = new bool[](stop_index-start_index+1);
        for (uint i = start_index; i <= stop_index; i++) {
            packageID[i] = addedPackages[i];
            (, , , , , , , totalEarnedPack[i], purchasesCount[i], last_PID[i]) = getPackageInfo(addedPackages[i], userID);
            if (last_PID[i] > 0) {
                ( , , last_timestamp[i], , last_expired[i]) = getPurchaseInfo(last_PID[i]);
            }  
        }
    }


    // Return the information of a purchaseID, included the expiration flag
    function getPurchaseInfo(uint purchaseID) public view returns (uint userID, uint16 packageID, uint timestamp, uint duration, bool expired) {
        require(purchaseID > 0 && purchaseID <= PIDcount, "PID not exist");
        userID = purchasesList[purchaseID].userID;
        packageID = purchasesList[purchaseID].packageID;
        timestamp = purchasesList[purchaseID].timestamp;
        duration = purchasesList[purchaseID].duration;
        expired = duration > 0 ? ( block.timestamp > timestamp + duration ? true : false ) : false;
    }


    // Return the purchases information in chunks. Depending on the input parameters it can return the global purchase list (eg. to calculate the income of the business), the purchases of the userID or the purchases of the userID but for a given packageID (eg. in the case of packages that can be rebought).
    // In the case of the global purchases list, the PID is (i+1) where i is the index of the returned data (from start to stop index, that is count_all-1 at maximum).
    // In the other cases the userID is an input argument, known, so we return the PIDs instead of the userIDs.
    function getAllPurchases(uint userID, uint16 packageID, uint start_index, uint stop_index, bool only_last) public view returns (uint count_all, uint[] memory userIDs_or_PIDs, uint16[] memory packageIDs, uint[] memory timestamps, uint[] memory durations, bool[] memory expireds) {
        // If userID = 0 get from the global purchase list
        // If userID is a valid user, and packageID = 0, get from the user bought list
        // If userID is a valid user and packageID a valid package, get from the bought list of that user for that package
        require(stop_index >= start_index, "Invalid index parameter");
        if (userID == 0) {
            count_all = PIDcount;
        } else {
            require(userID <= lastIDCount, "User not valid");
            if (packageID == 0) {
                count_all = userInfos[userIDaddress[userID]].bought_packages_array.length;
            } else {
                require(packagesIndex[packageID].price > 0, "Package does not exists");
                count_all = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array.length;
            }
        }
        if (count_all > 0) {
            // Only last element option
            if (only_last) {
                start_index = count_all - 1;
                stop_index = start_index;
            }
            // Coerce to length of the list if needed
            if (stop_index >= count_all) {
                stop_index = count_all - 1;
            }
            userIDs_or_PIDs = new uint[](stop_index-start_index+1);
            packageIDs = new uint16[](stop_index-start_index+1);
            timestamps = new uint[](stop_index-start_index+1);
            durations = new uint[](stop_index-start_index+1);
            expireds = new bool[](stop_index-start_index+1);
            // Populate the arrays depending on the case
            if (userID == 0) {
                for (uint i = start_index; i <= stop_index; i++) {
                    (userIDs_or_PIDs[i], packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(i+1);
                }
            } else if (packageID == 0) {
                uint[] memory purchases_array = userInfos[userIDaddress[userID]].bought_packages_array;
                for (uint i = start_index; i <= stop_index; i++) {
                    ( , packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(purchases_array[i]);
                    userIDs_or_PIDs[i] = purchases_array[i];
                }
            } else {
                uint[] memory purchases_array = userInfos[userIDaddress[userID]].packagesData[packageID].bought_array;
                for (uint i = start_index; i <= stop_index; i++) {
                    ( , packageIDs[i], timestamps[i], durations[i], expireds[i]) = getPurchaseInfo(purchases_array[i]);
                    userIDs_or_PIDs[i] = purchases_array[i];
                }
            }
        }
    }


    // Get the information about a given user, using either the address or the ID. If a packageID is given, also some information related to the package are returned (for the given user). Invited users are returned in chunks. 
    // The function returns also the global information of the smart contract and can be called with ID1 for this purpose.
    // For details about how data is organized in the return arrays, see the comments inside the function code. 
    function getUsersInfos(address tUserAddr, uint tUserID, uint16 packageID, uint invited_start_index, uint invited_stop_index) public view returns (uint[] memory globals, address[] memory addresses, uint[] memory IDs, uint[] memory counts, uint[] memory amounts, bool banned) {
        // Can use the user address or the user ID as reference. If tUserID is 0, the address will be used
        if (tUserID > 0) {
            tUserAddr = userIDaddress[tUserID];
        } else {
            if (tUserAddr == headWallet) {
                tUserAddr = headPlaceholder;
            }
            tUserID = userInfos[tUserAddr].id;
        }
        require(tUserID > 0 && tUserID <= lastIDCount, "Invalid ID");
        // Id a packageID > 0 is passed, the functions returns also the user date related to the particular package (eg. number of purchases, earnings)
        if (packageID > 0) {
            require(packageID <= PIDcount, "Invalid packageID");
        }
        // List of invited users can be returned in chunks
        require(invited_stop_index >= invited_start_index, "Invalid index parameter");      // Check on user given parameters
        if (userInfos[tUserAddr].invitedIDs.length == 0) {
            // Case of empty array
            invited_stop_index = 0;
            invited_start_index = 1;
        } else if (invited_stop_index >= userInfos[tUserAddr].invitedIDs.length) {
            // Coerce
            invited_stop_index = userInfos[tUserAddr].invitedIDs.length - 1;
        }
        // Create arrays
        globals = new uint[](6+maxDownLimit);
        addresses = new address[](8+1+invited_stop_index-invited_start_index);
        IDs = new uint[](8+1+invited_stop_index-invited_start_index);
        counts = new uint[](4);
        amounts = new uint[](2);
        // Global information: N_users | N_purchases | N_added_packages | BusinessEnabled | Project_% | Sponsor_% | Levels 1-5 %
        globals[0] = lastIDCount;
        globals[1] = PIDcount;
        globals[2] = addedPackages.length;
        globals[3] = businessEnabled ? 1 : 0;
        uint projectPercentage = 100;
        globals[5] = commission_per_level[0];
        projectPercentage -= globals[5];
        for (uint8 i = 6; i < maxDownLimit + 6; i++) {
            globals[i] = commission_per_level[i-5];
            projectPercentage -= globals[i];
        }
        globals[4] = projectPercentage;
        // Counts: N_invited | N_downline | N_purchases | N_purchases(PackageID)
        counts[0] = userInfos[tUserAddr].invitedIDs.length;
        counts[1] = userInfos[tUserAddr].downlineIDs.length;
        counts[2] = userInfos[tUserAddr].bought_packages_array.length;
        counts[3] = userInfos[tUserAddr].packagesData[packageID].bought_array.length;
        // Amounts: totalEarned | totalEarned(packageID)
        amounts[0] = userInfos[tUserAddr].totalEarned;
        amounts[1] = userInfos[tUserAddr].packagesData[packageID].totalEarnedPack;
        banned = userInfos[tUserAddr].banned;
        // IDs : userID | sponsorID | uplineID | DownlineIDs (5 elements, 0 if missing) | InvitedIDs (dynamic)
        // Addresses: the addresses associated to the above IDs
        IDs[0] = tUserID;
        IDs[1] = userInfos[tUserAddr].referrerID;
        IDs[2] = userInfos[tUserAddr].virtualID;
        addresses[0] = userIDaddress[IDs[0]];
        addresses[1] = userIDaddress[IDs[1]];
        addresses[2] = userIDaddress[IDs[2]];
        // maxDownLimit fixed spots for the downline (0 means the spot is free)
        for (uint8 i = 3; i < maxDownLimit + 3; i++) {
            if (i >= userInfos[tUserAddr].downlineIDs.length + 3) {
                IDs[i] = 0;
                addresses[i] = address(0);
            } else {
                IDs[i] = userInfos[tUserAddr].downlineIDs[i-3];
                addresses[i] = userIDaddress[IDs[i]];
            }
        }
        for (uint i = invited_start_index; i <= invited_stop_index; i++) {
            IDs[i+8] = userInfos[tUserAddr].invitedIDs[i];
            addresses[i+8] = userIDaddress[IDs[i+8]];
        }
    }


    // Convenience function to generate the keccak256 hash for an address. This is a pure function and does not store data in the blockchain.
    function addressToKeccakHash(address addr) public pure returns (uint256 address_hex, bytes32 address_hashed) {
        address_hex = uint256(addr);
        address_hashed = keccak256(abi.encodePacked(addr));
    }


    // Function used to debug the Round Robin memory. Can be removed in main-net version
    function roundRobinDebug(uint userID, uint elemID) public view returns (uint invitedCount, uint32 round_robin_next_index, uint round_robin_val) {
        invitedCount = userInfos[userIDaddress[userID]].invitedIDs.length;
        round_robin_next_index =  userInfos[userIDaddress[userID]].round_robin_next_index;
        round_robin_val =  userInfos[userIDaddress[userID]].round_robin[elemID];
    }


}