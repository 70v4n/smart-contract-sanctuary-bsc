pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";

import "./Util.sol";

import "./IRNG.sol";

contract RNG is IRNG, Ownable {
    uint256 public commitment_confirmation_cap = 1;
    bool public test_mode;

    mapping(bytes32 => uint256) commitments;
    mapping(bytes32 => uint256) rvalues;

    mapping(uint256 => bytes32) block_hashes;
    uint256 public	latest_block;

    constructor(bool _test_mode){
	test_mode = _test_mode;
    }

    function updateBlockHashes() external virtual {
	if((block.number - latest_block) > 255)
	    latest_block = block.number - 255;
	for(uint i=latest_block;i<block.number;i++)
	    block_hashes[i] = blockhash(i);
	latest_block = block.number;
    }

    function setCommitmentConfirmationCap(uint256 cap) external onlyOwner {
	commitment_confirmation_cap = cap;

	emit ConfirmationCap(cap);
    }

    function commit(bytes32 commitment) external {
	require((commitments[commitment] == 0),"The entropy should not have been commited before");
	commitments[commitment] = block.number;

	emit Commit(commitment);
    }

    function resetCommitment(bytes32 commitment) external onlyOwner {
	require(test_mode, "This method works in test mode only");
	commitments[commitment] = 0;
	rvalues[commitment] = 0;

	emit ResetCommitment(commitment);
    }

    function _getHash(uint256 _block_num) internal view returns (bytes32) {
	bytes32 _block_hash;
	if(block.number - _block_num > 255)
	    _block_hash = block_hashes[_block_num];
	else
	    _block_hash = blockhash(_block_num);
	return _block_hash;
    }

    function _getRandomValue(uint256 block_num, bytes32 user_entropy) internal view returns (uint256) {
	require((block.number - block_num  > commitment_confirmation_cap),"The entropy must have been committed at least the commitment_confirmation_cap blocks earlier");
	return uint256(keccak256(abi.encodePacked(_getHash(block_num+commitment_confirmation_cap), user_entropy)));
    }

    function lock(bytes32 entropy) external{
	bytes32 commitment = Util.deriveCommitment(entropy);
	require(rvalues[commitment] == 0, "The entropy should not have been locked before");
	uint256 block_num = commitments[commitment];
	require(block_num > 0, "The entropy must have been committed earlier");
	rvalues[commitment] = _getRandomValue(block_num,entropy);

	emit EntropyLock(commitment);
    }

    function read(bytes32 commitment) external view returns (uint256){
	return rvalues[commitment];
    }

    function getBlockConfirmationCap() external view returns (uint256){
	return commitment_confirmation_cap;
    }

    event ConfirmationCap(uint256 cap);
    event ResetCommitment(bytes32 commitment);
    event EntropyLock(bytes32 commitment);
    event Commit(bytes32 commitment);
}

/**
 * FireZard utilities lib
 */

pragma solidity ^0.8.0;

//import "./TagStorage.sol";

library Util {
    uint256 public constant MAX_UINT = (~uint256(0)-1);
//    bytes32 public constant DRAGON_CARD_TYPE_CODE = abi.encodePacked(keccak256('DRAGON_CARD'));
    bytes32 public constant DRAGON_CARD_TYPE_CODE = keccak256('DRAGON_CARD');

    enum CardRarity{ Ultra_Rare, Super_Rare, Rare, Uncommon, Common }
    enum CardType{ Fire, Ice, Plant, Electric, Water }
    enum StatType{ Integer, String, ByteArray, Boolean }

    struct Stat{
	string name;
	StatType statType;
	bool is_mutable;
    }

    struct StatValue{
	StatType statType;
	uint256  int_val;
	string   str_val;
	bytes32  bta_val;
	bool     bool_val;
    }

    function getTagKey(uint256 nft_id, string calldata name) public pure returns(bytes32) {
	return keccak256(abi.encodePacked(nft_id, name));
    }

    function getRandomItem(uint256 rvalue, uint256[] calldata distribution, uint256 size) public pure returns(uint256) {
	uint256 ratio = MAX_UINT/size;
	uint256 svalue = 0;
	for(uint256 i=0;i<distribution.length;i++){
	    svalue+=ratio*distribution[i];
	    if(rvalue < svalue)
		return i;
	}
	return distribution.length;
    }

      function deriveCommitment(bytes32 entropy) public pure returns (bytes32){
        return keccak256(abi.encodePacked(entropy));
    }

}

/**
 * Interface for Random Number Generator
 */

pragma solidity ^0.8.0;

interface IRNG {

    /**
     * @notice Commit a hidden entropy generated by a client.
     *
     * @param commitment Commitment for the client's entropy. For instrance, this can be hash of the entropy.
    **/
    function commit(bytes32 commitment) external;

    /**
     * @notice Lock client's entropy. Mix client's entropy with the entropy of a block that was mined before 
     * the method call, but after the block with the client's entropy commitment. 
     *
     * Note, that no miner knows client's entropy when it is commited to the blockchain and cannot manipulate the
     * hash of the block where client's entropy is mixed with the blockchain entropy, since client's entropy is actually revealed
     * after the lock block is mined. On the other hand, the client cannot predict the blockchain entropy either, when the 
     * client's and blockchain's entropies get mixed.
     *
     * @param entropy Client's entropy
    **/
    function lock(bytes32 entropy) external;

    /**
     * @notice Read the (pseudo-)random number derived from the client's and blockchain entropies. The number is uniquely defined by
     * the client's entropy commitment.
     *
     * @param commitment The commitment identifying the resulting randomly generated number
    **/
    function read(bytes32 commitment) external view returns (uint256);
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)

pragma solidity ^0.8.0;

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }
}

// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)

pragma solidity ^0.8.0;

import "../utils/Context.sol";

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * By default, the owner account will be the one that deploys the contract. This
 * can later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the deployer as the initial owner.
     */
    constructor() {
        _transferOwnership(_msgSender());
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby removing any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}