//register with 200000 gas limit, if lower it wont execute. after executing 10times to chg counter, LINK balance reduced by 0.8LINK
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// KeeperCompatible.sol imports the functions from both ./KeeperBase.sol and
// ./interfaces/KeeperCompatibleInterface.sol
//import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";
//import "https://raw.githubusercontent.com/smartcontractkit/chainlink/develop/contracts/src/v0.7/KeeperCompatible.sol";

import "./keeperbase.sol";
import "./keepercompatibleinterface.sol";

abstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}

 

contract test_contract { //this is another contract which already deploy earlier
    
    function withdraw_once() external payable {}
    
    //function a() public pure returns (uint) {}
    
}

contract Counter is KeeperCompatibleInterface {
    /**
    * Public counter variable
    */
    uint public counter;

    /**
    * Use an interval in seconds and a timestamp to slow execution of Upkeep
    */
    uint public immutable interval;
    uint public lastTimeStamp;

    test_contract ext_contract;
    
    

    constructor(uint updateInterval) {
      interval = updateInterval;
      lastTimeStamp = block.timestamp;

      counter = 0;
    }

    function set_ext_contract(address _t) public { //set address of external contract alredy deploy
        ext_contract =  test_contract(_t);
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
       if (counter < 2) {
           upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
            // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
 

       }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        lastTimeStamp = block.timestamp;
        counter = counter + 1;
        ext_contract.withdraw_once(); //call ext_contract funct
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }
}